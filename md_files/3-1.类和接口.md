### 使类和成员变量的访问范围尽量变小
封装（信息隐藏）：良好的类设计会隐藏内部设计的细节和 数据，只通过api与外部交互。
1. 尽可能得使类和成员不被外界类访问。
2. 实例域绝不应该是public,因为如果是public，则当此实例域指向一个可变对象时，你无法控制可变对象的状态，很有可能外部类直接通过实例域来直接改变引用类。
###  在公有类中使用访问方法而不是直接访问公有域
公有类如果有公有域很可能被外部类直接调用，如果是这样则无法再改变此公有域，因为一旦改变则很可能影响到外部类的使用，从面向对象的角度来看也应该通过api 方法来访问数据。如果类是包级或者是私有嵌套类则没有什么不妥。
### 使可变性变小
如果一个类是不可变的则此类直接就是线程安全的
使类成为不可变规则：
1.不提供任何修改类状态的方法。
2.保证类不会被扩展。防止子类继承final 修饰。
3.使所有域用final修饰。
4.使所有的域private.
5.确保对任何可变组件对象的互斥访问。方法不反回可变对象，不用外部提供的可变对象直接赋值初始化对象。可以使用保护性拷贝进行保护，即不直接赋值或者返回，重新构造新对象。

### 复合优于继承

继承：
优点：继承可以重复利用父类的方法扩展新特性，实现类的层次化。
缺点：继承必须跟随父类更新而更新，安全性脆弱，打破了类的封装性。
复合模式：
持有复合对象的private 实例，对某一方法的调用进行转发，保持了类的封装性。

应用场景：当真正的 A is B的时候用继承。如果不是一般用复合来实现。

### 要么为了继承而设计，并提供详细文档
1.如果确定是为了继承而设计的类，则需要可能被继承或者复写的方法提供详细文档。

2.如果不确定是为了继承的普通类，我们应该禁止子类化。
 禁止子类化可以用final 修饰类，或者利用private构建器实现。
###  接口优于抽象类
类可以继承一个抽象类，但是可以实现多个接口。
接口是构建非层次化类的有效途径。
目前接口中也可以定义默认方法。
抽象类和接口目前都可以增加新的方法。总体来说接口的演变性可以与抽象类相媲美了。

### 接口只用于定义类型
某个类实现某个接口，表示某个类具有了某一类型的行为。可以充当某一类型。为了其他目的定义接口都是不恰当的。
### 类的层次优于标签类
### 用函数对象表示策略
comparator
函数指针（lambda）的主要作用就是实现策略模式。

### 优先考虑静态成员类
嵌套类：静态成员类（可看做类内的普通类）
非静态成员类（内部类）
匿名类（内部类）
方法类（内部类）

- 如果嵌套类想要在外部类实例之外存在则必须是静态内部类
- 如果非静态内部类始终不需要访问外部实例，则可以声明为static
- 非静态内部类，一般用作外部类的Adapter，使外部类成为另一个不相关类的实例。 例如Map 类中的集合View
- 私有的静态内部类一般用来代表外部类的对象组件（singleton 静态内部类实现）

